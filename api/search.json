[{"id":"abb0ec656c45a2c76d49905531a07360","title":"音频测试","content":"\n      \n\n\n\n\nzhimaoi:戳这里\n","slug":"音频测试","date":"2022-08-09T02:10:50.504Z","categories_index":"测试","tags_index":"测试","author_index":"神游君的小站"},{"id":"a6d071d67758e4f09db8905fdf8c8cbc","title":"IOI 2021 - 游记","content":"IOI 2020 - 游记DAY 0MIT 集训结束了，乘飞机飞往新加坡。在组委会的各种安排下，我神奇的和美国队队长 Benjianmin Pi 和俄罗斯队队长 lldar Ganullin 坐在了一起。\n从波士顿飞往新加坡需要 20 个小时的时间，飞机上太无聊，准备看电影。我们这一排只有我面前的电视是好的，而且只有意大利语电影。\n我觉得挺有趣，但他们俩都说看不懂。于是花 5 分钟出了十道联赛难度的试题给他们做。\n我看了三部电影之后问他们做完没有。 400iq 说他没有任何思路; Benp 稍微强一点，拿出了 50 页打满的草稿纸说他推了 5 个小时终于会了第一题 5 分的暴力，现在已经写了 1000+ 行代码了，还没调出来。\n亏他们还是大国国家队的队长，连联赛难度的试题都做不出。第一题不就是一个裸的可持久化动态仙人掌维护最小费用无源汇有上下界可行流再套上拓展 9 模数广义分治 FFT 吗？连这都做不出 IOI 他们不是要爆零了。\n本来准备看第 4 部电影的，可是他们俩坚持让我讲题。我没有办法准备 3 分钟结束，可是才说两句话 Benp 就说他掉线了。\n之后，有一道题讲了四五遍 400iq 都说听不懂，我用俄语再给他讲了两遍，他还是不懂，最后发现他不会「轨道稳定化子」的俄语单词，害我讲了半天。\n讲了 10 个小时终于讲完了前两题，他们还是半懂不懂的状态。\n下飞机后 Benp 说他在飞机上想好了，打完这场 IOI 就当场退役，彻底淡出竞赛圈。但这完全不是我的问题，我也没有想到他们俩会这么菜，早知道就给他们做入门题了。\n这次下飞机是走的楼梯，我一出舱门就看到 IOI 主席跪在下面迎接我，新加坡总统和第一夫人坐在超长林肯里跟我挥手示意。\n我别过两位菜鸡，反手进了车门，并在总统府中享用晚餐。\n感觉总统花园里的游泳池太小了，只有 1km×1km ，游 1s 就游完了对角线，完全不够我施展身手。总统也感到很是抱歉，并表示马上会开发太平洋游泳池供我使用。\nDAY 1清晨常规晨练，绕着新加坡跑了 3 圈欧拉回路，感觉这城市还是太小了。\n看完三个题发现好像都比较可做的样子，第二题一眼以为是转化为 68 连通之后搞搞，结果发现答案只有 452 种可能。\n感受一下感觉第二题比较恶心，于是就决定先做第一题再做第三题再做第二题。\n第一题做到一半发现暴力居然有 5pts ，瞬间感觉自己写正解是在做无谓的努力，然后随便搞了 9 分钟，感觉非常稳，过了样例就 A 了。\n第三题猜想只要使用狄利克雷非主特征随便容斥下，结果写了个暴力发现大样例跑出来了，然后开始加两句优化跑两下，就拿到了 99.5pts。\n然而这是不行的，居然只有 99.5pts 。\n于是愉快地开始瞎做，做到一半发现我的方法好像有点吊，随便上个树状数组优化的 min25 筛套杜教筛就可以了，顿时感觉我走上了 AK 之路。思考了两秒发现没什么问题，就开始码 min26 筛了。\n接着到了下午两点半宣布考试过了一半了。我开始刚 T2 。\n结果发现果然 T2 才是最难刚的，一开始觉得只要维护一个可持久化动态仙人掌的想法是不行了，不改成仙人掌链剖分套圆方树感觉会超时。\n然后开始想别的做法，发现好像可以枚举一个点判断周围 68 维空间的情况，然后正要开始写的时候发现不会判不连通。然后发现前面那个仙人掌链剖分的方法好像也不太好做了。\n于是开始写写写，发现各种对，过了样例发现判 68 维空间好像比较容易，想象了一下 68 维空间长什么样子，然后瞎几把猜了个结论就 A 了。\n好像AK了，非常感动。\n最后说下我对题目的看法吧，我觉得这次 IOI 的题目还算比较科学，只不过难度较低，随便就 AK 了。\nDAY 1.5和美国队的选手交流了一下，他们 4 个都是华裔，所以交流起来也没什么困难。\n我问 Benp:\n“您哪里挂了？”\nBenp:\n“没挂，就是不会。”\n这时旁边的 400iq 用俄文和队友交流：\n&amp;%@&amp;@IOI￥%*&amp;，@!#%*I_AK_IOI&amp;!,&amp;（￥……\n(“我觉得这一届 IOI 好难，可是 I_AK_IOI 一直说简单，我也不知道为什么。。。”)\nDAY 2本来还以为第二天会难一点，可是 IOI 科学委员会又让我失望了。\n一看 T1 ，这不是我徒弟 mathew98 出的水题吗？当时我头都气炸了，之前他自信满满的把这题出给我看，我当场就把他的电脑摔地上。你出这么水的题是在侮辱我的智商吗？到时候被全场切可别说你是我的徒弟！\n现在倒好，他被我逐出师门之后有开始给 IOI 出题了。\n\n\n\n\n\n\n\n\n\n但好歹还是比赛，我花了 2 秒钟切掉了它，准备比赛结束后再去跟他算账。\n再看 T2 ，这不是我在飞机上给他们出的第 10 题吗？\n我当时是故意把最水的题留在最后的，估计那两个人又切了，唉。\n\n\n\n\n\n\n\n\n\n再看 T3 ，好像是 Tarjan 老爷子 2019 年的最新论文，只是一个快速动态图。只写了 2000 行就写完了，完全不过瘾哪 作为一场世界级大赛的压轴题，实现难度这么低实在是太没有区分度了。\n现在比赛才开始 10 分钟，实在是不想提前离场，于是就自己搭了一个LOL玩了四个小时五十分钟。\n比赛结束了，我装作十分遗憾的样子。\n只见 400iq 一脸自信的向我走来，看来也是 AK 了。我上前询问情况，他说自己推了 4 个小时性质终于找到了 T1 的关键性质，拿到的 50 分，基本上 Au 是稳了。\n不是， mathew98 这么水的题你没有 1s 看出结论是怎么当上俄罗斯队长的？\n出来一看榜，只有我一个人得分大于 100 ， Benp 状态不佳，虽然他也看过 Tarjan 的论文，但是他好像只会暴力，只拿到 49 分的部分分，屈居第三。\nDAY n终于结束了\n","slug":"装逼游记","date":"2022-08-09T02:10:50.501Z","categories_index":"游记","tags_index":"学术","author_index":"神游君的小站"},{"id":"a984f57e1da9f79870d16287059389d1","title":"绝对的暴力","content":"#include&lt;iostream>\n#include&lt;cstdio>\n#include&lt;cstring>\n\nusing namespace std;\n\nint n;\nstring a[100][100];\nint l[100];\nchar sum[100];\nint w[1100];\nint ll, f;\nint flag;\nint main()\n&#123;\n    cin >> n;\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = 1; j &lt;= n; j++)\n            cin >> a[i][j];\n    for (int i = 2; i &lt;= n; i++)\n    &#123;\n        sum[i] = a[1][i][0];\n    &#125;\n    if (n == 3)\n    &#123;\n        for (int i1 = 0; i1 &lt; n - 1; i1++)\n        &#123;\n            for (int i2 = 0; i2 &lt; n - 1; i2++)\n            &#123;\n                flag = 0;\n                if (i1 != i2)\n                &#123;\n                    w[sum[2]] = i1;\n                    w[sum[3]] = i2;\n                    for (int j = 2; j &lt;= n; j++)\n                    &#123;\n                        for (int k = 2; k &lt;= n; k++)\n                        &#123;\n                            ll = a[j][k].size();\n                            f = 1;\n                            for (int kk = 0; kk &lt; ll; kk++)\n                                f *= w[a[j][k][kk]];\n                            f %= n - 1;\n                            if (f != (w[sum[k]] + w[sum[j]]) % (n - 1)) flag = 1;\n                        &#125;\n                    &#125;\n                    if (flag == 0)\n                    &#123;\n                        cout &lt;&lt; a[1][2] &lt;&lt; \"=\" &lt;&lt; i1 &lt;&lt; \" \" &lt;&lt; a[1][3] &lt;&lt; \"=\" &lt;&lt; i2 &lt;&lt; endl &lt;&lt; n - 1;\n                        return 0;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if (n == 4)\n    &#123;\n        for (int i1 = 1; i1 &lt; n - 1; i1++)\n        &#123;\n            for (int i2 = 2; i2 &lt; n - 1; i2++)\n            &#123;\n                for (int i3 = 0; i3 &lt; n - 1; i3++)\n                &#123;\n                    flag = 0;\n                    if (i1 != i2 &amp;&amp; i1 != i3 &amp;&amp; i2 != i3)\n                    &#123;\n                        w[sum[2]] = i1;\n                        w[sum[3]] = i2;\n                        w[sum[4]] = i3;\n                        for (int j = 2; j &lt;= n; j++)\n                        &#123;\n                            for (int k = 2; k &lt;= n; k++)\n                            &#123;\n                                ll = a[j][k].size();\n                                f = 1;\n                                for (int kk = 0; kk &lt; ll; kk++)\n                                &#123;\n                                    f *= w[a[j][k][kk]];\n                                &#125;\n                                f %= n - 1;\n                                if (f != (w[sum[k]] + w[sum[j]]) % (n - 1)) flag = 1;\n                            &#125;\n                        &#125;\n                        if (flag == 0)\n                        &#123;\n                            cout &lt;&lt; a[1][2] &lt;&lt; \"=\" &lt;&lt; i1 &lt;&lt; \" \" &lt;&lt; a[1][3] &lt;&lt; \"=\" &lt;&lt; i2 &lt;&lt; \" \" &lt;&lt; a[1][4] &lt;&lt; \"=\" &lt;&lt; i3 &lt;&lt; endl &lt;&lt; n - 1;\n                            return 0;\n                        &#125;\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n    &#125;\n    if (n == 5)\n    &#123;\n        for (int i1 = 0; i1 &lt; n - 1; i1++)\n        &#123;\n            for (int i2 = 0; i2 &lt; n - 1; i2++)\n            &#123;\n                for (int i3 = 0; i3 &lt; n - 1; i3++)\n                &#123;\n                    for (int i4 = 0; i4 &lt; n - 1; i4++)\n                    &#123;\n                        flag = 0;\n                        if (i1 != i2 &amp;&amp; i1 != i3 &amp;&amp; i1 != i4 &amp;&amp; i2 != i3 &amp;&amp; i2 != i4 &amp;&amp; i3 != i4)\n                        &#123;\n                            w[sum[2]] = i1;\n                            w[sum[3]] = i2;\n                            w[sum[4]] = i3;\n                            w[sum[5]] = i4;\n                            for (int j = 2; j &lt;= n; j++)\n                            &#123;\n                                for (int k = 2; k &lt;= n; k++)\n                                &#123;\n                                    ll = a[j][k].size();\n                                    f = 1;\n                                    for (int kk = 0; kk &lt; ll; kk++)\n                                        f *= w[a[j][k][kk]];\n                                    f %= n - 1;\n                                    if (f != (w[sum[k]] + w[sum[j]]) % (n - 1)) flag = 1;\n                                &#125;\n                            &#125;\n                            if (flag == 0)\n                            &#123;\n                                cout &lt;&lt; a[1][2] &lt;&lt; \"=\" &lt;&lt; i1 &lt;&lt; \" \" &lt;&lt; a[1][3] &lt;&lt; \"=\" &lt;&lt; i2 &lt;&lt; \" \" &lt;&lt; a[1][4] &lt;&lt; \"=\" &lt;&lt; i3 &lt;&lt; \" \" &lt;&lt; a[1][5] &lt;&lt; \"=\" &lt;&lt; i4 &lt;&lt; endl &lt;&lt; n - 1;\n                                return 0;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n\n        &#125;\n    &#125;\n    if (n == 6)\n    &#123;\n        for (int i1 = 0; i1 &lt; n - 1; i1++)\n        &#123;\n            for (int i2 = 0; i2 &lt; n - 1; i2++)\n            &#123;\n                for (int i3 = 0; i3 &lt; n - 1; i3++)\n                &#123;\n                    for (int i4 = 0; i4 &lt; n - 1; i4++)\n                    &#123;\n                        for (int i5 = 0; i5 &lt; n - 1; i5++)\n                        &#123;\n\n                            flag = 0;\n                            if (i1 != i2 &amp;&amp; i1 != i3 &amp;&amp; i1 != i4 &amp;&amp; i1 != i5 &amp;&amp; i2 != i3 &amp;&amp; i2 != i4 &amp;&amp; i2 != i5 &amp;&amp; i3 != i4 &amp;&amp; i3 != i5 &amp;&amp; i4 != i5)\n                            &#123;\n                                w[sum[2]] = i1;\n                                w[sum[3]] = i2;\n                                w[sum[4]] = i3;\n                                w[sum[5]] = i4;\n                                w[sum[6]] = i5;\n                                for (int j = 2; j &lt;= n; j++)\n                                &#123;\n                                    for (int k = 2; k &lt;= n; k++)\n                                    &#123;\n                                        ll = a[j][k].size();\n                                        f = 1;\n                                        for (int kk = 0; kk &lt; ll; kk++)\n                                            f *= w[a[j][k][kk]];\n                                        f %= n - 1;\n                                        if (f != (w[sum[k]] + w[sum[j]]) % (n - 1)) flag = 1;\n                                    &#125;\n                                &#125;\n                                if (flag == 0)\n                                &#123;\n                                    cout &lt;&lt; a[1][2] &lt;&lt; \"=\" &lt;&lt; i1 &lt;&lt; \" \" &lt;&lt; a[1][3] &lt;&lt; \"=\" &lt;&lt; i2 &lt;&lt; \" \" &lt;&lt; a[1][4] &lt;&lt; \"=\" &lt;&lt; i3 &lt;&lt; \" \" &lt;&lt; a[1][5] &lt;&lt; \"=\" &lt;&lt; i4 &lt;&lt; \" \" &lt;&lt; a[1][6] &lt;&lt; \"=\" &lt;&lt; i5 &lt;&lt; endl &lt;&lt; n - 1;\n                                    return 0;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n    &#125;\n    if (n == 7)\n    &#123;\n        for (int i1 = 0; i1 &lt; n - 1; i1++)\n        &#123;\n            for (int i2 = 0; i2 &lt; n - 1; i2++)\n            &#123;\n                for (int i3 = 0; i3 &lt; n - 1; i3++)\n                &#123;\n                    for (int i4 = 0; i4 &lt; n - 1; i4++)\n                    &#123;\n                        for (int i5 = 0; i5 &lt; n - 1; i5++)\n                        &#123;\n                            for (int i6 = 0; i6 &lt; n - 1; i6++)\n                            &#123;\n\n                                flag = 0;\n                                if (i1 != i2 &amp;&amp; i1 != i3 &amp;&amp; i1 != i4 &amp;&amp; i1 != i5 &amp;&amp; i1 != i6 &amp;&amp; i2 != i3 &amp;&amp; i2 != i4 &amp;&amp; i2 != i5 &amp;&amp; i2 != i6 &amp;&amp; i3 != i4 &amp;&amp; i3 != i5 &amp;&amp; i3 != i6 &amp;&amp; i4 != i5 &amp;&amp; i4 != i6 &amp;&amp; i5 != i6)\n                                &#123;\n                                    w[sum[2]] = i1;\n                                    w[sum[3]] = i2;\n                                    w[sum[4]] = i3;\n                                    w[sum[5]] = i4;\n                                    w[sum[6]] = i5;\n                                    w[sum[7]] = i6;\n                                    for (int j = 2; j &lt;= n; j++)\n                                    &#123;\n                                        for (int k = 2; k &lt;= n; k++)\n                                        &#123;\n                                            ll = a[j][k].size();\n                                            f = 1;\n                                            for (int kk = 0; kk &lt; ll; kk++)\n                                                f *= w[a[j][k][kk]];\n                                            f %= n - 1;\n                                            if (f != (w[sum[k]] + w[sum[j]]) % (n - 1)) flag = 1;\n                                        &#125;\n                                    &#125;\n                                    if (flag == 0)\n                                    &#123;\n                                        cout &lt;&lt; a[1][2] &lt;&lt; \"=\" &lt;&lt; i1 &lt;&lt; \" \" &lt;&lt; a[1][3] &lt;&lt; \"=\" &lt;&lt; i2 &lt;&lt; \" \" &lt;&lt; a[1][4] &lt;&lt; \"=\" &lt;&lt; i3 &lt;&lt; \" \" &lt;&lt; a[1][5] &lt;&lt; \"=\" &lt;&lt; i4 &lt;&lt; \" \" &lt;&lt; a[1][6] &lt;&lt; \"=\" &lt;&lt; i5 &lt;&lt; \" \" &lt;&lt; a[1][7] &lt;&lt; \"=\" &lt;&lt; i6 &lt;&lt; endl &lt;&lt; n - 1;\n                                        return 0;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n    &#125;\n    if (n == 8)\n    &#123;\n        for (int i1 = 0; i1 &lt; n - 1; i1++)\n        &#123;\n            for (int i2 = 0; i2 &lt; n - 1; i2++)\n            &#123;\n                for (int i3 = 0; i3 &lt; n - 1; i3++)\n                &#123;\n                    for (int i4 = 0; i4 &lt; n - 1; i4++)\n                    &#123;\n                        for (int i5 = 0; i5 &lt; n - 1; i5++)\n                        &#123;\n                            for (int i6 = 0; i6 &lt; n - 1; i6++)\n                            &#123;\n\n                                for (int i7 = 4; i7 &lt; n - 1; i7++)\n                                &#123;\n                                    flag = 0;\n                                    if (i1 != i2 &amp;&amp; i1 != i3 &amp;&amp; i1 != i4 &amp;&amp; i1 != i5 &amp;&amp; i1 != i6 &amp;&amp; i1 != i7 &amp;&amp; i2 != i3 &amp;&amp; i2 != i4 &amp;&amp; i2 != i5 &amp;&amp; i2 != i6 &amp;&amp; i2 != i7 &amp;&amp; i3 != i4 &amp;&amp; i3 != i5 &amp;&amp; i3 != i6 &amp;&amp; i3 != i7 &amp;&amp; i4 != i5 &amp;&amp; i4 != i6 &amp;&amp; i4 != i7 &amp;&amp; i5 != i6 &amp;&amp; i5 != i7 &amp;&amp; i6 != i7)\n                                    &#123;\n                                        w[sum[2]] = i1;\n                                        w[sum[3]] = i2;\n                                        w[sum[4]] = i3;\n                                        w[sum[5]] = i4;\n                                        w[sum[6]] = i5;\n                                        w[sum[7]] = i6;\n                                        w[sum[8]] = i7;\n                                        for (int j = 2; j &lt;= n; j++)\n                                        &#123;\n                                            for (int k = 2; k &lt;= n; k++)\n                                            &#123;\n                                                ll = a[j][k].size();\n                                                f = 1;\n                                                for (int kk = 0; kk &lt; ll; kk++)\n                                                    f *= w[a[j][k][kk]];\n                                                f %= n - 1;\n                                                if (f != (w[sum[k]] + w[sum[j]]) % (n - 1)) flag = 1;\n                                            &#125;\n                                        &#125;\n                                        if (flag == 0)\n                                        &#123;\n                                            cout &lt;&lt; a[1][2] &lt;&lt; \"=\" &lt;&lt; i1 &lt;&lt; \" \" &lt;&lt; a[1][3] &lt;&lt; \"=\" &lt;&lt; i2 &lt;&lt; \" \" &lt;&lt; a[1][4] &lt;&lt; \"=\" &lt;&lt; i3 &lt;&lt; \" \" &lt;&lt; a[1][5] &lt;&lt; \"=\" &lt;&lt; i4 &lt;&lt; \" \" &lt;&lt; a[1][6] &lt;&lt; \"=\" &lt;&lt; i5 &lt;&lt; \" \" &lt;&lt; a[1][7] &lt;&lt; \"=\" &lt;&lt; i6 &lt;&lt; \" \" &lt;&lt; a[1][8] &lt;&lt; \"=\" &lt;&lt; i7 &lt;&lt; endl &lt;&lt; n - 1;\n                                            return 0;\n                                        &#125;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n    &#125;\n    if (n == 9)\n    &#123;\n        //枚举8个字母的值 \n        for (int i1 = 0; i1 &lt; n - 1; i1++)\n        &#123;\n            for (int i2 = 0; i2 &lt; n - 1; i2++)\n            &#123;\n                for (int i3 = 0; i3 &lt; n - 1; i3++)\n                &#123;\n                    for (int i4 = 0; i4 &lt; n - 1; i4++)\n                    &#123;\n                        for (int i5 = 0; i5 &lt; n - 1; i5++)\n                        &#123;\n                            for (int i6 = 0; i6 &lt; n - 1; i6++)\n                            &#123;\n                                for (int i7 = 4; i7 &lt; n - 1; i7++)\n                                &#123;\n                                    for (int i8 = 0; i8 &lt; n - 1; i8++)\n                                    &#123;\n                                        flag = 0; \n                                        if (i1 != i2 &amp;&amp; i1 != i3 &amp;&amp; i1 != i4 &amp;&amp; i1 != i5 &amp;&amp; i1 != i6 &amp;&amp; i1 != i7 &amp;&amp; i1 != i8 &amp;&amp; i2 != i3 &amp;&amp; i2 != i4 &amp;&amp; i2 != i5 &amp;&amp; i2 != i6 &amp;&amp; i2 != i7 &amp;&amp; i2 != i8 &amp;&amp; i3 != i4 &amp;&amp; i3 != i5 &amp;&amp; i3 != i6 &amp;&amp; i3 != i7 &amp;&amp; i3 != i8 &amp;&amp; i4 != i5 &amp;&amp; i4 != i6 &amp;&amp; i4 != i7 &amp;&amp; i4 != i8 &amp;&amp; i5 != i6 &amp;&amp; i5 != i7 &amp;&amp; i5 != i8 &amp;&amp; i6 != i7 &amp;&amp; i6 != i8 &amp; i7 != i8)\n                                        &#123; \n                                            w[sum[2]] = i1;\n                                            w[sum[3]] = i2;\n                                            w[sum[4]] = i3;\n                                            w[sum[5]] = i4;\n                                            w[sum[6]] = i5;\n                                            w[sum[7]] = i6;\n                                            w[sum[8]] = i7;\n                                            w[sum[9]] = i8;\n\n                                            for (int j = 2; j &lt;= n; j++)\n                                            &#123;\n                                                for (int k = 2; k &lt;= n; k++)\n                                                &#123; \n                                                    ll = a[j][k].size();\n                                                    f = 1; \n                                                    for (int kk = 0; kk &lt; ll; kk++)\n                                                        f *= w[a[j][k][kk]]; \n                                                    f %= n - 1;\n                                                    if (f != (w[sum[k]] + w[sum[j]]) % (n - 1)) flag = 1; \n                                                &#125;\n                                            &#125;\n                                            if (flag == 0)\n                                            &#123;\n                                                cout &lt;&lt; a[1][2] &lt;&lt; \"=\" &lt;&lt; i1 &lt;&lt; \" \" &lt;&lt; a[1][3] &lt;&lt; \"=\" &lt;&lt; i2 &lt;&lt; \" \" &lt;&lt; a[1][4] &lt;&lt; \"=\" &lt;&lt; i3 &lt;&lt; \" \" &lt;&lt; a[1][5] &lt;&lt; \"=\" &lt;&lt; i4 &lt;&lt; \" \" &lt;&lt; a[1][6] &lt;&lt; \"=\" &lt;&lt; i5 &lt;&lt; \" \" &lt;&lt; a[1][7] &lt;&lt; \"=\" &lt;&lt; i6 &lt;&lt; \" \" &lt;&lt; a[1][8] &lt;&lt; \"=\" &lt;&lt; i7 &lt;&lt; \" \" &lt;&lt; a[1][9] &lt;&lt; \" \" &lt;&lt; i8 &lt;&lt; endl &lt;&lt; n - 1;\n                                                return 0;\n                                            &#125;\n                                        &#125;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n    &#125;\n    cout &lt;&lt; \"ERROR!\";\n&#125; \n\n肉眼可看见的难\nA了这道题！！！！！！\n\n","slug":"绝对的暴力！！！","date":"2022-08-09T02:10:50.498Z","categories_index":"","tags_index":"编程","author_index":"神游君的小站"},{"id":"9444cf14352d1414c72ed0624ccf758d","title":"故宫博物院 —— 太和门","content":"\n时代：清康熙\n分类：殿\n区域：外朝中路\n　　太和殿，俗称“金銮殿”，位于紫禁城南北主轴线的显要位置，明永乐十八年（1420年）建成，称奉天殿。嘉靖四十一年（1562年）改称皇极殿。清顺治二年（1645年）改今名。自建成后屡遭焚毁，又多次重建，今天所见为清代康熙三十四年(1695年)重建后的形制。　　太和殿面阔11间, 进深5间，建筑面积2377.00㎡，高26.92m，连同台基通高35.05m，为紫禁城内规模最大的殿宇。其上为重檐庑殿顶，屋脊两端安有高3.40m、重约4300kɡ的大吻。檐角安放10个走兽，数量之多为现存古建筑中所仅见。　　太和殿的装饰十分豪华。檐下施以密集的斗栱，室内外梁枋上饰以和玺彩画。门窗上部嵌成菱花格纹，下部浮雕云龙图案，接榫处安有镌刻龙纹的鎏金铜叶。殿内金砖铺地，明间设宝座，宝座两侧排列6根直径1.00m的沥粉贴金云龙图案的巨柱，所贴金箔采用深浅两种颜色，使图案突出鲜明。宝座前两侧有四对陈设：宝象、甪（音录）端、仙鹤和香亭。宝象象征国家的安定和政权的巩固；甪端是传说中的吉祥动物；仙鹤象征长寿；香亭寓意江山稳固。宝座上方天花正中安置形若伞盖向上隆起的藻井。藻井正中雕有蟠卧的巨龙，龙头下探，口衔宝珠。　　太和殿前有宽阔的平台，称为丹陛，俗称月台。月台上陈设日晷、嘉量各一，铜龟、铜鹤各一对，铜鼎18座。龟、鹤为长寿的象征。日晷是古代的计时器，嘉量是古代的标准量器，二者都是皇权的象征。殿下为高8.13m的三层汉白玉石雕基座，周围环以栏杆。栏杆下安有排水用的石雕龙头，每逢雨季，可呈现千龙吐水的奇观。　　明清两朝24个皇帝都在太和殿举行盛大典礼，如皇帝登极即位、皇帝大婚、册立皇后、命将出征，此外每年万寿节、元旦、冬至三大节，皇帝在此接受文武官员的朝贺，并向王公大臣赐宴。清初，还曾在太和殿举行新进士的殿试，乾隆五十四年（1789年）始，改在保和殿举行，“传胪”仍在太和殿举行。　　太和殿是紫禁城内体量最大、等级最高的建筑物，建筑规制之高，装饰手法之精，堪列中国古代建筑之首。\n","slug":"故宫博物院-——-太和门","date":"2022-08-09T02:10:50.494Z","categories_index":"学习","tags_index":"故宫","author_index":"神游君的小站"},{"id":"cd12a74471a3bc74a9949744064078d4","title":"从零开始建立一个网站","content":"\n\n\n\n\n\n\n\n\n写给想要拥有一个自己的网站但没有资金成本的小白与曾经的自己。\n前言虽说是网站，对于个人来说，或许一般叫作博客。但我不希望它仅仅是一个博客，而是能够成为一个处于自己现实生活之外、自由、实验、不用畏惧他人眼光甚至可以独断专行的地方。\n当然，这本质还是一个新手向教程，也许会有点科普的感觉。我会从整体上对搭建网站的流程和使用到的技术及步骤进行介绍（因为要铺开讲，倘若包括轶事，实在太多太杂，我也会点到为止），并让你明白这个东西在网站的过程中起到什么样的作用。但我不会就细枝末节展开叙述，譬如如何注册账号、安装时如何点击下一步。我希望看完此篇文章后，此前对此方面知识一无所知的小白，到最后也能搭建出一个属于自己的站点。（前提是认识基础的英语单词和善用搜索引擎）\n已经有所基础的同学大可跳读或者直接关闭。\n\n\n\n\n\n\n\n\n\n注释处多为相关补充说明，对正常流程没有影响，若没有兴趣，可以略过。\n与文章相关疑问都可在本文章的 GitHub Issues 中进行评论，其他疑问可到对应项目或文章下评论。\n我会尽可能保持更新该文章所使用到的技术和做法，并随时接受勘误。\n关键词\nHexo\n静态博客\n无服务器\nGitHub Pages\nhexo-theme-yun（私货）\n\n步骤安装 Node.js\n\n\n\n\n\n\n\n\n什么是 Node.js ？这得从什么是 JS 说起，JS 也就是 JavaScript。（为什么有种从盘古开天辟地开始的感觉）没错，JavaScript 就是网页的盘古。JavaScript 是一种编程语言，我们所见到的网页中的交互和逻辑处理几乎都是由 JavaScript 完成。JavaScript 语法简单，易学易用。（当然也请不要小瞧它，虽然它入门门槛低，但上限同样也很高。包括但不限于实现网站前后端，手机桌面应用程序，机器学习，计算机图形学等。）在 Node.js 诞生前，JavaScript 都运行于浏览器端。也就是说，它是鱼，浏览器是装满了水的水缸。2008 年，Chrome V8 诞生。2009 年，Node.js 诞生。并成为 GitHub 早期最著名的开源项目。GitHub 可能大家已有所了解，后续再说。Node.js 便是一个基于 Chrome V8 引擎的 JavaScript 运行环境。（当年第一次看到这句话时，我也一脸懵逼。）按照我的理解，JavaScript 是鱼，Chrome V8 就是抽水机，Node.js 则把这台抽水机也装在你电脑上。于是你的电脑也有了 Node.js 这个和浏览器相似的水缸，也可以在里面运行 JavaScript 了！当然 Node.js 和浏览器端还是因为自身定位和一些历史原因而有些许区别的，不再展开。Node.js | 百度百科JavaScript | MDN\n下载｜ Node.js\n建议下载长期支持版而非当前发布版（因为如果是最新版，容易出现一些奇妙的 bug）。\n全部默认下一步进行安装。\nWindows 打开命令提示符，macOS 打开终端。（&#x3D; &#x3D;，这个不会就请百度吧。）Linux 用户右上角关闭本标签页。\n后续如提到输入命令，均默认指打开终端进行输入。\n输入 node --version，如果得到的版本号与你方才安装的一致，那么 Node.js 就已经成功安装。\n\n\n\n\n\n\n\n\n\nNode.js 安装成功时也默认安装了 npm，在此后将会用到。npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。\n对了，国内使用 npm 可能很慢。\n你可以考虑切换为 taobao 镜像源。\nnpm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\n\n\n\n\n\n\n\n\n\n\n\n\nnpm &amp; yarn 常用包与命令\n\n\n\n\n\n\n\n\n\n\nyarn 是 Facebook 出品的另一个包管理工具，同样可以管理 npm 中的包，安装已缓存的包时速度更快，你也可以使用它来替代 npm。\n官网下载或通过命令行安装。\nnpm install -g yarn\n\n\n\nGit 与 GitHub安装 Git\n\n\n\n\n\n\n\n\nVisual Studio Code，简称 VS Code。目前最为强大易用的编辑器，轻量且快速。（宇宙第一编辑器）注意：它并不是我们常常听到的 VS，VS 常常指的是 Visual Studio，是一个功能强大的 IDE（集成开发环境），体积也相比 VS Code 都要大上一个量级。\n在此之前，我建议你先安装 VS Code。因为安装 Git Bash 时，可以设置 VS Code 作为默认编辑器。\n\n\n\n\n\n\n\n\n\nGit 是一个开源的分布式版本控制系统，由 Linus Torvalds（同时也是 Linux 的作者）为了管理 Linux 开发而开发。简而言之，是一个版本管理工具。譬如设计师设计好了第三版的海报，客户却说还是要第一版吧，这时便可以通过 Git 快速回退到最初的版本。你只需要把每次更改的状态（Git 会自动进行检测，你只要掌握基础的几条命令就可以了）告诉 Git，而不需要每个版本都保存一份压缩包，既方便也能大大节约空间。（当然这主要只对代码文本起作用，因为 Git 的本质是记录各行代码的增减，倘若是像视频、海报这类二进制文件来说便体现不出丝毫优势了。当然想要应对这种场景还有 Git LFS。）\n下载 Git 并安装（如果国内速度太慢，可以试试这里）\nmacOS 用户可以下载官网的安装包进行安装，也可以直接安装 App Store 的 Xcode（附带会安装 Git，但是比较大）。\n\n\n\n\n\n\n\n\n\n类似的工具还有：SVN。但始终更推荐 Git，因为它功能更为强大且它的背后还有更强大的生态：GitHub。\n注册 GitHub这一部分内容，你也可以放到本地调试并预览成功后并打算线上部署的时候，再回过头来看。\n\n\n\n\n\n\n\n\n\nGitHub 一听便与 Git 有所渊源。Git 在英文中是懒人、饭桶之意。Hub 则是中心、集线器的意思。譬如 USB 集线器就是 USB Hub。所以 GitHub 就是饭桶中心（大雾）。GitHub 是全世界最大的开源项目与代码托管平台，也是众多开发者的交流场所。还是全球最大的同性交友网站。而代码托管本身用到的正是上文提到的 Git 技术。\n注册 GitHub 账号。（虽然都是英文，但不必畏惧，也并不会造成使用障碍，只要记得最常用的选项含义即可，以及善用手头的翻译软件。）\n\n\n\n\n\n\n\n\n\n注意：注册时的英文用户名将成为你可以使用的免费域名前缀。\n登录 GitHub。\n\n\n\n\n\n\n\n\n\n为什么要用 GitHub？对于平民玩家来说，在初次尝试建立自己的网站时，也许并不会有闲钱或者说决心来购买自己的服务器与域名。而 GitHub 则提供了 GitHub Pages 这一服务。用户们可以利用这一服务，部署自己的静态站点。\n点击右上角的 + -&gt; New repository 新建仓库。\n\n\n\n\n\n\n\n\n\n\n我这里因为已经有同名仓库，所以提示了重复。\n仓库名称务必为 你的用户名.github.io，用户名是英文，大小写无所谓，但建议统一小写。（因为你会发现时常切换大小写很麻烦）\n\n\n\n\n\n\n\n\n\n为什么必须这个作为仓库名？GitHub Pages 服务的命名规范，同时它也将成为你的专属域名。当然，你也可以购置自己的专属域名并用它来提供内容。\n点击 Create repository。\n安装 HexoHexo\n\nGitHub: https://github.com/hexojs/hexo\n官方文档（直接参考文档也是一个不错的选择）\n\n\n\n\n\n\n\n\n\n\n为嘛使用 Hexo ？Hexo 是一个快速、简洁而强大的博客框架，基于 Node.js，同样托管于 GitHub 之上。生态中拥有众多插件主题。你可以基于它快速生成一些静态页面。你可以使用别人的各种主题与插件，也可以自己定制开发想要的功能。为什么不是…?其他常用的博客框架还有 WordPress，Typecho，Ghost 等，但这些往往都需要购置自己的服务器，而无法静态化地部署到 GitHub Pages 上。（当然，相应的功能和灵活性也大大提升。）静态化站点还有一个优势就是访问速度往往更快。静态网站生成器还有 Vuepress，Gatsby 等。但这些多是为了写文档而量身定制的，你也可以使用它们，但是相较 Hexo 的博客定位，它们关于博客的插件和主题以及解决办法会少得多。Hexo 提供的功能与 Hugo 几乎都有，（生成大量文件时，甚至比 Hexo 更快）不过它是基于 GO 语言。日后你想对自己的网站进行自定义，即便是 Hugo，你编写前端的交互仍旧需要使用 JavaScript，所以选择基于 JavaScript 的 Hexo 可以降低学习成本。（你若对 GO 有兴趣，仍然可以尝试使用 Hugo，但本教程将不会针对 Hugo 进行展开。）所以对于新手来说，使用 Hexo 作为起始点，不失为一个好选择。（当然如果你有钱租服务器，并希望快速上手的话，就可以考虑考虑 WordPress 或者 Typecho）这里顺带推荐一下小伙伴 染川瞳 的 WordPress 主题 Sakurairo，阔落 的 Typecho 主题 miracles，都是很漂亮的主题。\n在终端中输入以下命令：\nnpm install hexo-cli -g\n# 如果安装失败，可能是没有权限，可以尝试头部加上 sudo 重新执行\n# sudo npm install hexo-cli -g\n\n\n\n\n\n\n\n\n\n\n\n\ninstall 自然是安装。hexo-cli 则是 hexo 的终端工具，可以帮助你生成一些模版文件，之后再用到。-g 代表的是全局安装。也就是在任何地方都可以使用，否则会只能在安装的目录下使用。\n此时，请先通过 cd 进入你本地电脑打算存储网站代码的文件夹目录。（或者右键文件夹 Git Bash Here）\n\n\n\n\n\n\n\n\n\ncd | DOS 命令cd （LINUXSHELL 命令）\n譬如：\n\n\n\n\n\n\n\n\n\n注意：这里是你自定义的目录，请不要复制粘贴\n# &#39;#&#39; 字符后的文字代表注释，不需要输入\n# Windows\ncd C:\\Users\\YunYou\\Documents\\GitHub\\\n# macOS\n# cd &#x2F;Users&#x2F;yunyou&#x2F;github&#x2F;\n\n\n\n接下来输入：\nhexo init 你的名字.github.io\n\n\n\n\n\n\n\n\n\n\n\n\nhexo 正是因为我们之前安装了 hexo-cli 这一个包，所以我们可以在终端中使用 hexo 这一命令。init 初始化博客的模版文件。后面跟的是你要新建的文件夹，最好和你此前新建的仓库名一致。\n# 进入你的博客文件夹\ncd 你的名字.github.io\n# 默认安装所有 &#96;package.json&#96; 文件中提到的包\nnpm install\n# 你也可以缩写成 hexo s\nhexo server\n\n\n\nserver 代表开启本地的 Hexo 服务器，这时你就可以打开浏览器，在地址栏中输入 localhost:4000 就可以看到本地的网页了。\n按 Ctrl + C 中断服务器的运行。\n至此，基础的模版页面便已经搭建好了。\n使用 Hexo 主题Hexo 默认提供的是 hexo-theme-landscape 主题。默认主题样式简单，功能较少。所以大多数人并不会使用默认主题。\n这里将示范如何使用我自己开发的主题 hexo-theme-yun。\n\n\n\n\n\n\n\n\n\n\n(:з」∠) 顺带求 Star，代表收藏，就在点进链接后的右上角。\n你可以前往 云游君的小站 查看示例效果。\nHexo-Theme-Yun 的速度检测\n谷歌 PageSpeed Insights\n谷歌浏览器 Audits - Lighthouse 检测分数\n当然，你也可以在 Themes | Hexo 发现更多有趣美丽的主题。使用方法大致相同。当你具备一定开发能力时，你可以开发属于自己的主题，或者为 hexo-theme-yun 提交 PR 添加你想要的功能。\n\nhexo-theme-yun - GitHub\nhexo-theme-yun 使用文档：更详细的配置进阶指南。\n示例效果\n\n下载 Hexo 主题进入终端（确保路径处于你此前使用 Hexo 初始化好的文件夹目录下，即 xxx.github.io，后简称为 Hexo 目录），输入以下命令。\n\n\n\n\n\n\n\n\n\n实际上你也可以直接在 VS Code 中使用终端。\ngit clone https:&#x2F;&#x2F;github.com&#x2F;YunYouJun&#x2F;hexo-theme-yun themes&#x2F;yun\n\n\n\n\n\n\n\n\n\n\n\n\n这里便使用到了我们此前安装的 Git，git clone 即代表克隆（也就是复制的作用）我的主题（托管于 GitHub，链接便是主题所在的地址），themes/yun 则代表放在你 Hexo 文件夹下的 themes/yun 文件夹里（没有该文件夹会自动新建）。\n编辑 Hexo 配置\n\n\n\n\n\n\n\n\n右键文件夹使用 VS Code 打开，或者进入 VS Code 打开你存储网站的文件夹。此后操作都将默认你已处于该工作目录下。\n在你此前通过 Hexo 初始化生成的文件目录下，会存在一个 _config.yml 文件。\n\n\n\n\n\n\n\n\n\nyml 是 YAML 文件的后缀名，YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言） 的缩写，但它实际上还是一种标记语言。你可以将其理解为存储数据的一种文本格式，这也是其诞生的目的。 如果你听说过 JSON，那你就更能明白它是干什么的了。\n它是 Hexo 的配置文件，关于各配置选项的意义你可以查看 配置 | Hexo。\n在 _config.yml 中找到 theme 这个字段，将其后的 landscape 修改为 yun。\ntheme: yun\n\n\n\n\n\n\n\n\n\n\n\n\npug 是一种模板引擎，可以渲染为 HTML 字符串。类似的还有 ejs，swig 等，语法和设计理念有所不同。stylus 是一种 CSS 预处理器，可以渲染为 CSS。类似的还有 scss，less，同样只是语法和设计理念有所差异。\n由于我的主题使用了 pug 和 stylus，而 Hexo 自带的一般是 ejs 与 stylus，所以你可能还需要输入以下命令安装渲染器。\nnpm install hexo-render-pug hexo-renderer-stylus\n# 如果出问题，可以换 yarn 安装试试。\n\n\n\n这时再像此前那般使用 hexo server 重新启动服务器，你就可以看到一个不一样的主题风格的页面了。\n自定义主题配置当启动时，会使用主题的默认配置。但这不一定是你想要的。所以你可以对主题进行一些自定义。\n主题的配置文件放在 themes/yun/_config.yml 文件中。且慢，你最好不要直接修改主题的默认配置。倘若日后主题升级更新了怎么办，难道还要重新配置一遍吗？\n最好的解决方案就是在博客根目录下（不是主题目录）新建 source/_data/yun.yml。（若 source/_data 目录不存在，请新建）\n本主题将自定义配置与默认配置进行合并，因此你只需要在 yun.yml 文件中自定义你需要的配置即可，其余仍将自动采用默认配置。\n譬如我们需要更换头像。在 yun.yml 中填写。\n\n\n\n\n\n\n\n\n\n你可以在 source 文件夹下新建 images 文件夹，用来存储你的图片。也可以使用 SM.MS 等图床工具配合 PicGo 上传你的图片文件，获取在线链接。\navatar:\n  url: /images/avatar.jpg # 你的头像图片地址\n  rounded: true\n  opacity: 1\n\n\n\n更换主题色彩，比如换成黑色，黑色的十六进制颜色代码是 #000000。\ncolors:\n  primary: \"#000000\"\n\n\n\n这时你的主题色调就会变为黑色。\n这只是一个配置项的简单示例，更多配置你可以参考 Yun 主题文档 或直接在 theme/yun/_config.yml 中查看，并根据自己的需要进行配置。\n生成静态文件至今我们的工作都是在本地进行，想必你也很想放到线上与小伙伴们分享。这便轮到了 GitHub Pages 的出场，不过 GitHub Pages 只支持纯静态文件。\n所以我们需要使用以下命令先来生成站点的静态文件。\n# 如果进行多次生成，为了避免受错误缓存影响，最好使用 hexo clean 先清除一遍。\nhexo generate\n# 缩写为 hexo g\n\n\n\n此时你的文件夹目录下会出现 public 这个文件夹，里面存放的就是你站点的静态文件。\n与远程仓库建立关联接下来我们将本地的仓库与此前在 GitHub 上建立的仓库建立关联。\ngit init # 初始化 Git 仓库，只需要执行一次即可\n\n\n\n在将其部署到 GitHub Pages 上之前，我们最好先建立一个分支。\n\n\n\n\n\n\n\n\n\n什么是分支？Git 提供了版本管理功能，其中还有一个分支功能，你现在可以简单地将其理解为平行世界。\n你的名字.github.io 部署后，GitHub Pages 将默认使用你的 master 分支作为静态文件部署。所以我们最好新建一个 hexo 分支（命名无所谓）用来存储 Hexo 地源代码，master 分支则用来存储部署后的静态文件。\ngit checkout -b hexo\n\n\n\n这时便成功建立了一个 hexo 分支。（此后的工作都将在 hexo 分支下进行）\n你可以通过 git branch -v 来查看当前有哪些分支，使用 git checkout 分支名 来切换到对应的分支。\n\n\n\n\n\n\n\n\n\nGit 学习笔记\n部署为了更方便的部署到 GitHub Pages，Hexo 提供了 hexo-deployer-git 插件。\n老规矩，安装。\nnpm install hexo-deployer-git\n\n\n\n在 _config.yml 中配置。\ndeploy:\n  type: git\n  repo: 你此前新建的仓库的链接 # 比如：https://github.com/YunYouJun/yunyoujun.github.io\n  branch: master # 默认使用 master 分支\n  message: Update Hexo Static Content # 你可以自定义此次部署更新的说明\n\n\n\n保存，部署！\n\n\n\n\n\n\n\n\n\n第一次可能需要你输入用户名与密码。密码输入的时候不会出现 ***，不要害怕，已经输入进去了。\nhexo deploy\n\n\n\n等待完成后，打开网址 https://你的名字.github.io 就能看到你的线上网站了。\n\n\n\n\n\n\n\n\n\n使用 https，http 可能无法正常打开。HTTPS 是多了安全加密的 HTTP，Chrome 浏览器已经默认会显示 http 链接为不安全。为了安全，建议开启强制 https 跳转。项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Enforce HTTPS。（翻到下面）此时，http 网址会自动重定向到 https\n备份与自动部署我们当前只是将生成的静态文件部署到了云端。\n为了以防万一，我们应该将网站的源代码文件也推送到 GitHub 仓库备份。\n# 与远程 Git 仓库建立连接，只此一次即可\ngit remote add origin https://github.com/你的用户名/你的名字.github.io\n\n\n\n接下来准备提交，这几句命令将是你以后每次备份所需要输入。\n# 添加到缓存区\ngit add -A\ngit commit -m \"这次做了什么更改，简单描述下即可\"\n# 推送至远程仓库\ngit push\n# 第一次提交，你可能需设置一下默认提交分支\n# git push --set-upstream origin hexo\n\n\n\n每次推送都要输入这三条命令，你可能觉得有些麻烦。那么你可以编写 bash 脚本。\n譬如，在根目录下新建 update.sh。\n# 如果没有消息后缀，默认提交信息为 `:pencil: update content`\ninfo=$1\nif [\"$info\" = \"\"];\nthen info=\":pencil: update content\"\nfi\ngit add -A\ngit commit -m \"$info\"\ngit push origin hexo\n\n\n\n此后更新的话，只需要在终端执行 sh update.sh 即可。\n更新麻烦，每次部署也很麻烦，可以使用持续集成进行自动部署。\n\n\n\n\n\n\n\n\n\n什么是持续集成？持续集成是一种软件开发实践。对软件进行自动化构建，以此来发现错误。Travis CI 就是一个线上持续集成服务的提供商。它可以拉取你每次推送到 GitHub 上的代码，然后根据你的要求对其进行构建。我们可以趁机让它自动生成网站静态文件，然后自动帮我们部署。除此之外，你还可以使用 GitHub Actions ，Netlify 等服务。GitHub Actions 相比 Travis 等，自身便拥有仓库的 Token，不再需要额外设置，可以直接使用 secrets.GITHUB_TOKEN。推荐一个专门用来部署 gh-pages 的 Actions actions-gh-pages\n关于更多更具体的自动化部署方案和操作步骤，你可以参考我的小伙伴 ChrAlpha 的 初探无后端静态博客自动化部署方案。\n他在文章中详细介绍了 Netlify 、GitHub Actions 和 Travis CI 的部署方法。\n你也可以参考 Hexo 的官方文档 将 Hexo 部署到 GitHub Pages\n我就不在此画蛇添足。\n\n当然还有个更简便的方法，直接参考我的 gh-pages.yml。\n去掉夹在 yarn install 与 yarn build 之间的 algolia 部分，直接粘贴到你的 .github/workflows/ 文件夹（自己新建）下 xxx.yml 文件里即可。\n推送后便可直接自动部署。\n至此，你的站点便基本搭建完成，此后继续对主题进行自定义吧。\n\n\n\n\n\n\n\n\n\nYun 主题文档\n开始写作文章输入以下命令即可新建 xxx.md 文件。\nhexo new post xxx\n\n\n\n\n\n\n\n\n\n\n\n\nmd 是 Markdown 的后缀名，是一种简洁方便的文本标记语言。你只需要记住简单的几种语法，就可以快速进行编写。为什么使用 Markdown？首先 Hexo 本身就是将 Markdown 转化为静态的 Html 文件，来方便用户编写文章。Markdown 就好似介于 Word 与 TXT 文本之间。Word 体积大、大部分功能实际上根本用不到，且最后的文档常常带有许多冗余信息。而 TXT 却无法实现加粗、标题、下划线、水平分割线等常用的功能。（这里所说的 TXT 只是一种纯文本格式的代称，实际上 Markdown 也是纯文本文件，不过通过语法和 Markdown 编译器，我们就可以看到一些简单的样式。）\n譬如本文就是通过 Markdown 编写。\n# 一级标题\n\n## 二级标题\n\n**加粗文字**\n\n\n\n\n\n\n\n\n\n\n\n\n更多语法（虽然说是更多，但是其实也没多少）：Markdown 基本语法\n这是我写的一个 Markdown 样式：star-markdown-css\n上面是渲染过后的效果，你可以与其 Markdown 的纯文本原文进行对比。\n添加标签&#x2F;分类例如本文 Markdown 的头部。\n\n\n\n\n\n\n\n\n\nFront-matter\n---\ntitle: 教你如何从零开始搭建一个属于自己的网站\ndate: 2020-03-05 01:31:08\nupdated: 2020-07-14 16:31:00\ntags:\n  - 教程\n  - Hexo\n  - 分享\ncategories:\n  - 云游的小安利\n---\n\n你的文章内容\n\n\n\n页面你可以新建一些自己的自定义页面。\n譬如直接在 Hexo 目录下的 source 文件夹下直接新建 HTML 进行编写。\n也可以通过以下命令来新建页面。（当然还是 Markdown，不过也是可以在 Markdown 里写 HTML 的，也会被渲染出来。）\nhexo new page xxx\n\n\n\n说到这里，就不得不提一提本主题的特色功能了。\n生成你的老婆列表页面。按一定格式书写即可。见文档。\n\n\n\n\n\n\n\n\n\n预览：Lovely Girls\nFAQ视频？没有视频，一是懒，二是文字更利于更新勘误。\n以及文章中将会频繁出现参考链接，更方便使用。\n如何绑定你的自定义域名？首先，你得有个自己的域名。\n\n\n\n\n\n\n\n\n\n避免广告嫌疑，你可以自行前往相关域名提供商购买。但是如果你有幸能看到谷歌广告（概率较小），可以考虑点一点。\n并使用 CNAME 解析到 你的名字.github.io。（当然 A 记录直接解析到 GitHub Pages IP 地址也可以。）\n\n\n\n\n\n\n\n\n\nManaging a custom domain for your GitHub Pages site\n在 Hexo 工作目录下 source 文件夹下新建 CNAME 文件（没有后缀名）。\n\n\n\n\n\n\n\n\n\nCNAME 即相当于告诉 GitHub 允许将 xxx.github.io 为你的域名提供服务。source 目录下的文件除了特殊的 markdown 会被解析为 html，其余都会原样复制到生成的静态文件夹中。所以你需要在 source 文件夹下建有 CNAME，它会在生成静态文件时，将 CNAME 拷贝到静态文件夹并部署到 master 分支。如果只是在 GitHub 上设置（项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Custom domain），它会自动添加到 master 分支上，但随后不包含 CNAME 的部署会将其覆盖。\n内容填写你的域名即可。\n\n\n\n\n\n\n\n\n\nAbout custom domains and GitHub Pages\n备案如果想要使用国内的一些服务，比如 CDN，不备案确实寸步难行。\n此处我指的是 ICP 备案，并非公安备案。（实际上我从来没有进行过公安备案，且目前在使用服务时，并未受到任何相关限制。）\n\n\n\n\n\n\n\n\n\n我只在腾讯云备案过，所以只能分享一点此方面的经验。\n国内备案往往意味着你还需要一台国内的服务器，譬如通过腾讯云备案时会需要你设置关联的服务器（阿里云应当也是如此）。实际上你的网站并不一定得在这台服务器上，即便你只是免费试用了一个月，但是备案成功了，之后过期了对备案也不会有何影响。\n\n\n\n\n\n\n\n\n\n也就是说你完全可以使用学生优惠（10 元左右）购买一个月的云服务器，用于关联，并在这个月内抓紧备案好，此后云服务器过期不会影响备案问题。学生优惠的话 阿里云 或者 腾讯云 都有。\n备案前需要注意的几点就是：\n\n确定你的域名是否可以备案（一些少见&#x2F;独特的域名后缀，国内是无法备案的，比如 moe）\n关闭评论区\n提交备案时的备注说明不得含有 交流 字样\n首页不能含有其他网站的直达链接\n遵纪守法无不良信息（这是当然的）\n\n你也可以直接关停网站，等待备案成功后再重新打开。（今后每年偶尔会复查，但相对会宽松许多。）\n此后，按照网站指引的备案步骤一步步来即可。（以前还要等待幕布寄送拍照，现在可以直接在手机上人脸验证）\n备案成功后页脚必须清晰地展示备案号，且备案号含有指向 http://www.beian.miit.gov.cn/ 的超链接。\n更多可能有帮助的内容\n让百度收录你的 GitHub Pages 博客 - 云游君的小站\n使用 CDN 加速你的 GitHub Pages 网站 - 云游君的小站\n\n其他平台毕竟自己的站点可能还是不会有什么人看，所以发到其他平台了（然而还是没有人）。不过在这里阅读体验应该是最好的。\n\n教你如何从零开始搭建一个属于自己的网站 - 云游君的文章 - 知乎\n教你如何从零开始搭建一个属于自己的网站 - bilibili 专栏（不支持外链、代码高亮、Markdown，太难了）\n教你如何从零开始搭建一个属于自己的网站 - 腾讯云（该说不愧是腾讯吗？SEO 绝了。最晚（晚了几个星期）发的，次日搜全名就变百度第一条了。）\n\n结语个人网站同样可以用来做许多事情，你可以将其用来记录生活、回忆、创作、学习笔记、开发经验等（包括作为一个试验平台）。可以与熟悉的人分享，也可以作为另一个世界另一个自己的展示。\n多年后，回看起自己当初写下的内容，未尝不是件有趣的事情。\n善始者众，善终者寡。\n\n\n\n\n\n\n\n\n\n臣闻善作者，不必善成；善始者，不必善终。「史记·乐毅列传」\n希望大家能有毅力坚持下去，不忘初心。\n\n\n\n\n\n\n\n\n\n永远相信美好的事情即将发生\n相关讨论与问题，可前往 Discussions 反馈。\n\n\n\n\n\n\n\n\n\n主题相关问题请到 Issues ｜ hexo-theme-yun 反馈。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tby.yunyoujun\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n","slug":"建一个网站","date":"2022-08-09T02:10:50.489Z","categories_index":"网站","tags_index":"干货","author_index":"神游君的小站"},{"id":"bf1bcc06abda02cdb2aa23d5c980d9ff","title":"做一个坑人小程序","content":"做一个坑人小程序下载 DEV-C++下载链接：DEV-C++点击“码云(Gitee)” 或直接点这里\n安装DEV-C++打开下载下来的文件点击“确定”点击“我同意此协议”下一步一路点“确定”安装完成！！打开这个窗口就说明安装成功图示：\n注入灵魂(主题)上方菜单栏选择“工具”选择“编辑器选项”选择“语法高亮”拉出预设语法高亮方案滚动条滚下去……可以看到“塑型代码”点他点确定就变成这样：这是为了更有感觉\n开始写代码 重中之重代码我直接放上面原理自己琢磨\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tsystem(&quot;start abc&quot;);\n&#125;\n然后把文件命名为 abc点“编译”(不要直接点运行，会坑死自己)\n后期美化（更逼真）首先，我们可以看到编译后的目录里有一个名为abc.exe的文件把它放到其他盘，把源文件abc.cpp删掉右键点击“发送到”点击 桌面快捷方式把后面的“ - 快捷方式”删掉然后右键属性菜单栏找到“常规”点击更改图标一般学校机房都会装个谷歌浏览器所以我们选googlechrome浏览器的图标目录一般在C:\\Program Files\\Google\\Chrome\\Application 或C:\\Program Files (x86)\\Google\\Chrome\\Application就会出现这样：选择Chrome.exe选择一个点确定再点确定图标就改好啦再把名字改一下，完美！！(幸灾乐祸)\n\n\nByeBye~~\n邮箱：&#119;&#x70;&#112;&#x6f;&#112;&#x65;&#119;&#x6f;&#x7a;&#106;&#x63;&#64;&#111;&#x75;&#x74;&#108;&#x6f;&#111;&#107;&#46;&#99;&#x6f;&#x6d;\n","slug":"坑人","date":"2022-08-09T02:10:50.486Z","categories_index":"坑死人","tags_index":"坑死人","author_index":"神游君的小站"},{"id":"727dae2b0e40be3223ff1c9010885e0a","title":"用代码关闭极域电子教室","content":"极域电子教室的困扰影响着很多小学僧下面我们一步解决！首先你得会用 cmd按下一组快捷键：win+r在对话框里输入：cmd按回车弹出这样的窗口：里面输入：\ntaskkill -f -im studentmain.exe\n这样就好了！！！原理是：用taskkill来结束极域学生端的.exe程序好好学习吧！zhimaoi博客：戳这里\n","slug":"再见极域","date":"2022-08-09T02:10:50.483Z","categories_index":"cmd","tags_index":"干货","author_index":"神游君的小站"},{"id":"0327f06965e55f3999803ee72ce0b382","title":"Windows11 | 壁纸","content":"关于Windows11的一些壁纸\n\n\n\n\n\n\n\n\n拿去吧 拿去吧\n下载链接\n","slug":"Windows11壁纸","date":"2022-08-09T02:10:50.481Z","categories_index":"","tags_index":"学术","author_index":"神游君的小站"},{"id":"eb2fca299dccbba47ee002f18a19f14a","title":"更新中 | 一度让我震惊到的视频！！！","content":"一度让我震惊到的视频何同学 \n\n毕导THU \n\n\n\n\n\n\n\n\n\n\n内容更新中。。。\n","slug":"The video","date":"2022-08-09T02:10:50.478Z","categories_index":"视频","tags_index":"视频","author_index":"神游君的小站"},{"id":"d29d50d7960adcef9ecffe7f9ea8176f","title":"洛谷《P1126》题解","content":"洛谷《P1126》题解题面题目描述机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径1.6米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 N×M 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动1步（Creep）；向前移动2步（Walk）；向前移动3步（Run）；向左转（Left）；向右转（Right）。每个指令所需要的时间为1秒。请你计算一下机器人完成任务所需的最少时间。\n输入格式第一行为两个正整数_N,M(N,M ≤ 50)，下面_N_行是储藏室的构造，0表示无障碍，1表示有障碍，数字之间用一个空格隔开。接着一行有4个整数和1个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东E，南S，西W，北N_），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。\n输出格式一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出-1。\n\n输入输出样例输入9 10\n0 0 0 0 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 1 0\n0 0 0 1 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 1 0 0 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 1 0\n7 2 2 7 S\n\n输出12\n\n思路注意点\n首先，这道题需要注意：障碍物在格子上的，但是机器人是在交叉点上走路的。某人自信的写完代码后（就是我）写完代码后发现题读错了。\n那么还要注意到的地方是起点和终点是可能重合的，需要特殊处理；起点也可能是障碍物，也要做特殊处理。\n还有要注意到的是，对于每一步，你走一个格点，两个格点或三个格点所耗时间都是1，不要搞乱；而每转90°，也要耗一定时间，所以千万要小心。\n注意机器人是球形且有直径，所以机器人并不能到达储藏室的边缘。\n注意在移动时机器人也需要一步一步移动，所以机器人不能跨过障碍物，即遇到障碍物就必须停止。\n\n所需变量int fx[5]=&#123;0,-1,1,0,0&#125;; \nint fy[5]=&#123;0,0,0,-1,1&#125;;\nint ft[5]=&#123;0,1,4,2,3&#125;;\nint fft[5]=&#123;0,1,3,4,2&#125;;\nint abc[5]=&#123;0,1,2,1,0&#125;;\n\nfx[i]表示方向i(编号)的x的进退情况 。\nfy[i]表示方向i(编号)的y的进退情况 。\nft[i]表示顺时针排列各个方向的编号(上1 右4 下2 左3) 。\nfft[i]表示数字i在ft[]数组中的下标 。\nabc[5]表示转到[顺时针转i次到达的那个方向]的最短次数 。\n其中ft数组和abc数组比较难理解\n下面我们逐个讲讲\nabc数组int abc[5]=&#123;0,1,2,1,0&#125;;\n\n当i=4，最少0次；当i=3，最少1次；当i=2，最少2次；当i=1,最少1次\n不难看出当对于不同的i，也就是顺时针转动i次时，对应的最小旋转次数就是abc[i]。\nft数组int ft[5]=&#123;0,1,4,2,3&#125;;\n\n\n图中蓝圈内四个方向各有一个黑色数字代表方向编号，那么我们顺时针遍历一下就是1 4 2 3，是比较好理解的。\nBFS状态转移方程边界处理，因为机器人是有体积的，而我们是将其右上角当成其位置进行广搜，所以要保证：\n(x>=1&amp;&amp;x&lt;n&amp;&amp;y>=1&amp;&amp;y&lt;m)\n\n\n\n代码细节用队列存储每一个格点的信息，然后起点入队，每次从队首取出一个元素，根据这个元素旋转，直行，得到一个新的坐标，然后判断由这种方式到达的这个点是否是耗时最短的一种方式，此处用f[i][j]数组表示，然后队列为空后，输出f[终点的x][终点的y]即可。\nAC代码#include&lt;bits/stdc++.h>\n\nusing namespace std;\nint sd[55][55];\nint a[55][55];//a为读入的方格地图 \nint n, m;\nint x11, y11;//起点 \nint x2, y2;//终点 \nint f[55][55];//f为格点地图 \nint fx[5] = &#123;0, -1, 1, 0, 0&#125;;//fx[i]表方向i(编号)的x情况  \nint fy[5] = &#123;0, 0, 0, -1, 1&#125;;//fy[i]表方向i(编号)的y情况 \nint ft[5] = &#123;0, 1, 4, 2, 3&#125;;//ft[i]表示顺时针排列各个方向的编号(上1 右4 下2 左3) \nint fft[5] = &#123;0, 1, 3, 4, 2&#125;;//fft[i]表示数字i在ft[]数组中的下标 \n\nint abc[5] = &#123;0, 1, 2, 1, 0&#125;;//abc[5]表示转到[顺时针转i次到达的那个方向]的最短次数 \nstruct node &#123;\n    int x, y;//机器人当前点的坐标 \n    int t;//1=>N 2=>S 3=>W 4=>E 题目里的方向编号 \n    int time;//从起点到当前点的最短时间 \n&#125;;\n\nqueue&lt;node> q;//这是队列q \nstring ch;//这是读入起点的方向 \nint cto;//这是起点的方向 \n\nvoid fxto() &#123;\n    switch (ch[0]) &#123;\n        case 'N':\n            cto = 1;\n            break;\n        case 'S':\n            cto = 2;\n            break;\n        case 'W':\n            cto = 3;\n            break;\n        case 'E':\n            cto = 4;\n            break;\n    &#125;\n    return;\n&#125;\n\nvoid change() &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            if (sd[i][j] == 1)//如果当前格为障碍物，则它的四个顶点都不能走 \n            &#123;\n                a[i - 1][j] = 1;\n                a[i][j - 1] = 1;\n                a[i - 1][j - 1] = 1;\n                a[i][j] = 1;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main() &#123;\n    cin >> n >> m;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            scanf(\"%d\", &amp;sd[i][j]);\n        &#125;\n    &#125;\n    cin >> x11 >> y11 >> x2 >> y2;\n    cin >> ch;\n    fxto();//判断ch代表的方向 \n    change();//把方格地图转化为机器人可以走的格点地图 \n    node first;//起点 \n    first.x = x11;\n    first.y = y11;\n    first.t = cto;\n    first.time = 0;\n    q.push(first);//起点入队 \n    node u, d;\n    while (!q.empty()) &#123;\n        u = q.front();\n        q.pop();\n        for (int i = 1; i &lt;= 4; ++i) &#123;\n            int zhuan = abc[i];//[顺时针转i下的那个方向]的最短旋转次数 \n\n            //求出旋转完了以后方向的编号fangx(为了方便讨论，全部当做顺时针旋转) \n            int fangx = fft[u.t] + i;//此时fangx为下标 \n            if (fangx == 5) fangx = 1;\n            if (fangx == 6) fangx = 2;\n            if (fangx == 7) fangx = 3;\n            if (fangx == 8) fangx = 4;\n            fangx = ft[fangx];//此时fangx为方向编号 \n            //此时fangx存的是由当前点顺时针转了i次后到达的方向的编号\n\n            for (int j = 1; j &lt;= 3; ++j)//走1~3步 \n            &#123;\n                int lsx = u.x + fx[fangx] * j;//计算按当前旋转方向走j步的坐标 \n                int lsy = u.y + fy[fangx] * j;\n                if (lsx >= n || lsx &lt;= 0 || lsy >= m || lsy &lt;= 0 || (lsx == x11 &amp;&amp; lsy == y11) || a[lsx][lsy] == 1) &#123;\n                    //判断边界和障碍物 (特判：是否为起点)\n                    break;\n                &#125;\n                if ((u.time + zhuan + 1 &lt; f[u.x + fx[fangx] * j][u.y + fy[fangx] * j] ||\n                     f[u.x + fx[fangx] * j][u.y + fy[fangx] * j] == 0) &amp;&amp;\n                    a[u.x + fx[fangx] * j][u.y + fy[fangx] * j] == 0) &#123;//如果当前点可以刷新距离，就入队 \n                    d.x = u.x + fx[fangx] * j;\n                    d.y = u.y + fy[fangx] * j;\n                    d.t = fangx;\n                    d.time = u.time + zhuan + 1;\n                    f[u.x + fx[fangx] * j][u.y + fy[fangx] * j] = d.time;\n                    q.push(d);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if (f[x2][y2] == 0 &amp;&amp; (x2 != x11 || y2 != y11))//如果为0，代表不能走到 \n    &#123;\n        cout &lt;&lt; \"-1\" &lt;&lt; endl;\n    &#125; else//否则输出终点的距离 \n        cout &lt;&lt; f[x2][y2] &lt;&lt; endl;\n    return 0;\n&#125;\n\n","slug":"P1126","date":"2022-08-09T02:10:50.471Z","categories_index":"学习","tags_index":"题解,编程","author_index":"神游君的小站"},{"id":"4b144820332f464acabf29ba83de80a9","title":"有关oj运行机制的一点解释（持续更新。。。）","content":"很久以前就想专门写篇有关oj原理的博客了因为之前对电脑判题的原理有过质疑于是在极长的一段时间内妄想在网络上找到相关的解答后来在问老师问同学问博主问度娘一点一点解惑慢慢总结后大致覆盖了我目前的一些疑惑\n首先是有关在线评测系统运行原理及各种报错常因其实不难想象，电脑只是处理数据验证最后答案与期望答案是否相同，大部分的思考都由人来完成\noj一般有一组input文件和一组output文件，\n先运行你的程序，同时在后台开始计时，\n无法通过编译的是CE，编译时开的内存过大时MLE，然后开始运行，\n将所有input数据加入输入流中（数据量可能很大，几百万组什么的）\n在这种大数据下除非你的程序是完美的，否则不可能通过。\n将输出的内容和output文件比对，\n不完全一样的WA，数据一样当差换行和空格时是PE，若在计时器计时结束前你的程序未能和output匹配完成（已完成部分都正确）是TLE，输出流没有正常结束是OLE，运行时调用了非法地址时是RE，\n然后就是有关打榜时的要项在正式比赛中input包括两部分，\n一部分是出题人这对这道题可能的算法出的边缘数据，运算量最大的数据，特殊数据，\n另一部分是大数据，就是随机生成大量的合法数据，将数据通过标程给出结果。\n这两部分数据结合可以以极高的准确率判定提交的程序是否正确\n在正式比赛中依然有裁判组，\n他们只对ac率和预先估计相差极大的情况进行观察，\n必要时重写oj，进行rejudge，\n同时选手也可以申请裁判关注（裁判只对真正误判的情况回应），你所想的由专家手动判题的情况是不存在的。因为判题必须在极短时间完成。\n但是好多网络赛中及时向出题人反映的情况却不少见\n最后就是有关ac样例的疑点仅仅是通过了样例的程序远远不能ac，\n样例只是帮助你理解题意而已，\n通常样例无法检测出程序的错误。\n甚至有些样例是有误导性质的，\n要走的路还很远\nacm的题意描述通常是很严谨的，\n在题意允许的范围的数据都可能出现，\n特殊情况很多题目里还没说如何处理的情况几乎不存在。\n题没过检查一下，看看disguss，\n看看别人的解题报告什么的，有些东西做多了就理解了，\nHello world!\n个人博客（zhimaoi）戳这里\n个人博客（网站）戳这里\n转载自CSDN：原链接 戳这里\n(●&#39;◡&#39;●)\n调皮一下（秀Markdown语法）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n阿巴\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"OJ","date":"2022-08-09T02:10:50.468Z","categories_index":"OJ","tags_index":"学术","author_index":"神游君的小站"},{"id":"ff106531e7def00fe398dcd792198095","title":"MarkDown基本语法阐述","content":"主要内容\n\n\n\n\n\n\n\n\nMarkdown是什么？谁创造了它？为什么要使用它？怎么使用？谁在用？尝试一下\n正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。    \n2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。    \n他有着足以让你跪拜的人生经历：    \n\n14岁参与RSS 1.0规格标准的制订。     \n2004年入读斯坦福，之后退学。   \n2005年创建Infogami，之后与Reddit合并成为其合伙人。   \n2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。   \n2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。     \n2013年1月自杀身亡。\n\n\n天才都有早逝的归途。\n3. 为什么要使用它？\n它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。\n兼容HTML，可以转换为HTML格式发布。\n跨平台使用。\n越来越多的网站支持Markdown。\n更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）\n摆脱Word（我不是认真的）。\n\n4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。\nMarkdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，**反斜杠 \\，符号’&#96;’**。\n4.1 标题两种形式：1）使用=和-标记一级和二级标题。\n\n一级标题=========二级标题---------\n效果：\n\n\n\n\n\n\n\n\n\n一级标题   二级标题\n2）使用#，可表示1-6级标题。\n\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题    \n效果：\n\n\n\n\n\n\n\n\n\n一级标题二级标题三级标题四级标题五级标题六级标题\n4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。\n4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：\n\n&gt; 区块引用&gt;&gt; 嵌套引用  \n效果：\n\n\n\n\n\n\n\n\n\n区块引用  \n\n嵌套引用\n\n4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落：\nvoid main(){    printf(“Hello, Markdown.”);}    \n代码区块：\nvoid main()\n&#123;\n    printf(&quot;Hello, Markdown.&quot;);\n&#125;\n\n注意:需要和普通段落之间存在空行。\n4.5 强调在强调内容两侧分别加上*或者_，如：\n\n\n\n\n\n\n\n\n\n*斜体*，_斜体_**粗体**，__粗体__\n效果：\n\n\n\n\n\n\n\n\n\n斜体，斜体粗体，粗体\n4.6 列表使用·、+、或-标记无序列表，如：\n\n\n\n\n\n\n\n\n\n-（+*） 第一项-（+*） 第二项- （+*）第三项\n注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n效果：\n\n\n\n\n\n\n\n\n\n\n第一项\n第二项\n第三项\n\n有序列表的标记方式是将上述的符号换成数字,并辅以.，如：\n\n\n\n\n\n\n\n\n\n1 . 第一项2 . 第二项3 . 第三项    \n效果：\n\n\n\n\n\n\n\n\n\n\n第一项\n第二项\n第三项\n\n4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。\n4.8 链接链接可以由两种形式生成：行内式和参考式。行内式：\n\n\n\n\n\n\n\n\n\n[younghz的Markdown库](https::&#x2F;&#x2F;github.com&#x2F;younghz&#x2F;Markdown “Markdown”)。\n效果：\n\n\n\n\n\n\n\n\n\nyounghz的Markdown库。\n参考式：\n\n\n\n\n\n\n\n\n\n[younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https::&#x2F;&#x2F;github.com&#x2F;younghz&#x2F;Markdown “Markdown”[2]:https::&#x2F;&#x2F;github.com&#x2F;younghz&#x2F;Markdown “Markdown”    \n效果：\n\n\n\n\n\n\n\n\n\nyounghz的Markdown库1younghz的Markdown库2\n注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。\n4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。\n4.10 反斜杠\\相当于反转义作用。使符号成为普通符号。\n4.11 符号’&#96;’起到标记作用。如：\n\n\n\n\n\n\n\n\n\n`ctrl+a`\n效果：\n\n\n\n\n\n\n\n\n\nctrl+a    \n5. 谁在用？Markdown的使用者：\n\nGitHub\n简书\nStack Overflow\nApollo\nMoodle\nReddit\n等等\n\n6. 尝试一下\nChrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。\n在线的dillinger.io评价也不错   \nWindowns下的MarkdownPad也用过，不过免费版的体验不是很好。    \nMac下的Mou是国人贡献的，口碑很好。\nLinux下的ReText不错。\n\n当然，最终境界永远都是笔下是语法，心中格式化 :)。\n\n注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。\n\n以上基本是所有traditonal markdown的语法。\n其它：列表的使用(非traditonal markdown)：\n用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。\n\n\n\n代码库\n链接\n\n\n\nMarkDown\nhttps://github.com/younghz/Markdown\n\n\nMarkDownCopy\nhttps://github.com/younghz/Markdown\n\n\n关于其它扩展语法可参见具体工具的使用说明。\n","slug":"MarkDown基本语法","date":"2022-08-09T02:10:50.465Z","categories_index":"md","tags_index":"干货","author_index":"神游君的小站"},{"id":"3380c20bbc1a72ddf2040b8a18231bd1","title":"有关Visual Studio Code的种草","content":"\n\n\n什么是Visual Studio Code？简介\n\n\n\n\n\n\n\n\nVisual Studio Code（简称“VS Code”）是Microsoft在2015年4月30日Build开发者大会上正式宣布一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代Web和云应用的跨平台源代码编辑器 可在桌面上运行，并且可用于Windows，macOS和Linux。它具有对JavaScript，TypeScript和Node.js的内置支持，并具有丰富的其他语言（例如C++，C＃，Java，Python，PHP，Go）和运行时（例如.NET和Unity）扩展的生态系统。看看他的软件图标\n是不是让你看着很爽？下面我就讲讲怎么安装它\n特点\n\n\n\n\n\n\n\n\n1.轻量方便2.使用3.支持多种语言4.宇宙第一编辑器\n它的哥们下面我要介绍介绍它的哥们–Visual Studio（VS）\n\n\n\n\n\n\n\n\n\nMicrosoft Visual Studio（简称VS）是美国微软公司的开发工具包系列产品。VS是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等。所写的目标代码适用于微软支持的所有平台，包括Microsoft Windows、Windows Mobile、Windows CE、.NET Framework、.NET Compact Framework和Microsoft Silverlight 及Windows Phone。\n2022预览版：\n\n\n\n\n\n\n\n\n\n64 位版的 Visual Studio 不再受内存限制困扰，主 devenv.exe 进程不再局限于 4GB，用户可以打开、编辑、运行和调试最大和最复杂的解决方案\n相对于Code版，VS更大，更重，功能更多像我做文章就用的是VS\n现已发布正式版(不查我还真不知道)\n\nand\n\n在这边\n下载你可以在官网里下载\n也可以选择清华大学提供的：VSCodium\n安装不用我说了吧完成！！\n","slug":"Install-VSC","date":"2022-08-09T02:10:50.461Z","categories_index":"软件","tags_index":"软件","author_index":"神游君的小站"},{"id":"4debe1ef2cebe933ede14daabb523f9e","title":"关于身份证查验生日的事的一些解释","content":"关于身份证查验生日的事的一些解释这连我自己也看不清我写了什么\n#include&lt;iostream>\n#define NOMINMAX\n\nusing namespace std;\n\nstruct Birthday\n&#123;\n\tint y, m, d;\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; os, Birthday&amp; b)\n\t&#123;\n\t\tos &lt;&lt; b.y &lt;&lt; \"-\" &lt;&lt; b.m &lt;&lt; \"-\" &lt;&lt; b.d;\n\t\treturn os;\n\t&#125;\n\toperator long()\n\t&#123;\n\t\treturn y * 10000 + m * 100 + d;\n\t&#125;\n&#125;;\n\n\nlong getBirthdayNumberFromID(long);\nBirthday getBirthdayFromBirthdayNumber(long);\nBirthday getBirthdayFromID(long);\n\n\nint main()\n&#123;\n\treturn 0;\n&#125;\n\nlong getBirthdayNumberFromID(long id)\n&#123;\n\tlong a = id % 1000000000000;\n\tlong b = a / 10000;\n\treturn b;\n&#125;\n\nBirthday getBirthdayFromBirthdayNumber(long b)\n&#123;\n\tBirthday birthday = &#123; b / 10000,b % 10000 / 100,b % 10000 % 100 &#125;;\n\treturn birthday;\n&#125;\n\nBirthday getBirthdayFromID(long id)\n&#123;\n\treturn getBirthdayFromBirthdayNumber(getBirthdayNumberFromID(id));\n&#125;\n\n洛谷将会臭名昭著！！！\n\n结果\n\n\n\n\n\n\n\n\n\n注：kkksc03是洛谷站长\n洛谷账号：jason_zhou\n","slug":"code-school","date":"2022-08-09T02:10:50.454Z","categories_index":"","tags_index":"干货","author_index":"神游君的小站"},{"id":"04d02c6cf4fb7ff84ac1d34b8405801e","title":"空调样板房","content":"\n\n邮箱：&#x77;&#x70;&#x70;&#111;&#x70;&#x65;&#119;&#x6f;&#x7a;&#106;&#99;&#x40;&#111;&#x75;&#x74;&#108;&#x6f;&#111;&#107;&#46;&#x63;&#x6f;&#x6d;洛谷账号：Jason_Zhou洛谷主页：here鸣谢：yunyoujun&#x2F;云游君 here\n","slug":"AC-home","date":"2022-08-09T02:10:50.451Z","categories_index":"","tags_index":"空调","author_index":"神游君的小站"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-08-07T09:05:38.662Z","categories_index":"","tags_index":"","author_index":"神游君的小站"}]